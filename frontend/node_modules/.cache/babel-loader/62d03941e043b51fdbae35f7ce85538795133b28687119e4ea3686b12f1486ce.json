{"ast":null,"code":"import _objectSpread from \"/workspaces/ai-school/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/workspaces/ai-school/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"transition\", \"transitionEnd\"];\nimport { getOrigin, checkTargetForNewValues } from '../utils/setters.mjs';\nimport { parseDomVariant } from './utils/parse-dom-variant.mjs';\nimport { VisualElement } from '../VisualElement.mjs';\nclass DOMVisualElement extends VisualElement {\n  sortInstanceNodePosition(a, b) {\n    /**\n     * compareDocumentPosition returns a bitmask, by using the bitwise &\n     * we're returning true if 2 in that bitmask is set to true. 2 is set\n     * to true if b preceeds a.\n     */\n    return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n  }\n  getBaseTargetFromProps(props, key) {\n    return props.style ? props.style[key] : undefined;\n  }\n  removeValueFromRenderState(key, _ref) {\n    let {\n      vars,\n      style\n    } = _ref;\n    delete vars[key];\n    delete style[key];\n  }\n  makeTargetAnimatableFromInstance(_ref2, _ref3, isMounted) {\n    let {\n        transition,\n        transitionEnd\n      } = _ref2,\n      target = _objectWithoutProperties(_ref2, _excluded);\n    let {\n      transformValues\n    } = _ref3;\n    let origin = getOrigin(target, transition || {}, this);\n    /**\n     * If Framer has provided a function to convert `Color` etc value types, convert them\n     */\n    if (transformValues) {\n      if (transitionEnd) transitionEnd = transformValues(transitionEnd);\n      if (target) target = transformValues(target);\n      if (origin) origin = transformValues(origin);\n    }\n    if (isMounted) {\n      checkTargetForNewValues(this, target, origin);\n      const parsed = parseDomVariant(this, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n    return _objectSpread({\n      transition,\n      transitionEnd\n    }, target);\n  }\n}\nexport { DOMVisualElement };","map":{"version":3,"names":["getOrigin","checkTargetForNewValues","parseDomVariant","VisualElement","DOMVisualElement","sortInstanceNodePosition","a","b","compareDocumentPosition","getBaseTargetFromProps","props","key","style","undefined","removeValueFromRenderState","_ref","vars","makeTargetAnimatableFromInstance","_ref2","_ref3","isMounted","transition","transitionEnd","target","_objectWithoutProperties","_excluded","transformValues","origin","parsed","_objectSpread"],"sources":["/workspaces/ai-school/frontend/node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs"],"sourcesContent":["import { getOrigin, checkTargetForNewValues } from '../utils/setters.mjs';\nimport { parseDomVariant } from './utils/parse-dom-variant.mjs';\nimport { VisualElement } from '../VisualElement.mjs';\n\nclass DOMVisualElement extends VisualElement {\n    sortInstanceNodePosition(a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props.style ? props.style[key] : undefined;\n    }\n    removeValueFromRenderState(key, { vars, style }) {\n        delete vars[key];\n        delete style[key];\n    }\n    makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target }, { transformValues }, isMounted) {\n        let origin = getOrigin(target, transition || {}, this);\n        /**\n         * If Framer has provided a function to convert `Color` etc value types, convert them\n         */\n        if (transformValues) {\n            if (transitionEnd)\n                transitionEnd = transformValues(transitionEnd);\n            if (target)\n                target = transformValues(target);\n            if (origin)\n                origin = transformValues(origin);\n        }\n        if (isMounted) {\n            checkTargetForNewValues(this, target, origin);\n            const parsed = parseDomVariant(this, target, origin, transitionEnd);\n            transitionEnd = parsed.transitionEnd;\n            target = parsed.target;\n        }\n        return {\n            transition,\n            transitionEnd,\n            ...target,\n        };\n    }\n}\n\nexport { DOMVisualElement };\n"],"mappings":";;;AAAA,SAASA,SAAS,EAAEC,uBAAuB,QAAQ,sBAAsB;AACzE,SAASC,eAAe,QAAQ,+BAA+B;AAC/D,SAASC,aAAa,QAAQ,sBAAsB;AAEpD,MAAMC,gBAAgB,SAASD,aAAa,CAAC;EACzCE,wBAAwBA,CAACC,CAAC,EAAEC,CAAC,EAAE;IAC3B;AACR;AACA;AACA;AACA;IACQ,OAAOD,CAAC,CAACE,uBAAuB,CAACD,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EACpD;EACAE,sBAAsBA,CAACC,KAAK,EAAEC,GAAG,EAAE;IAC/B,OAAOD,KAAK,CAACE,KAAK,GAAGF,KAAK,CAACE,KAAK,CAACD,GAAG,CAAC,GAAGE,SAAS;EACrD;EACAC,0BAA0BA,CAACH,GAAG,EAAAI,IAAA,EAAmB;IAAA,IAAjB;MAAEC,IAAI;MAAEJ;IAAM,CAAC,GAAAG,IAAA;IAC3C,OAAOC,IAAI,CAACL,GAAG,CAAC;IAChB,OAAOC,KAAK,CAACD,GAAG,CAAC;EACrB;EACAM,gCAAgCA,CAAAC,KAAA,EAAAC,KAAA,EAAgEC,SAAS,EAAE;IAAA,IAA1E;QAAEC,UAAU;QAAEC;MAAyB,CAAC,GAAAJ,KAAA;MAARK,MAAM,GAAAC,wBAAA,CAAAN,KAAA,EAAAO,SAAA;IAAA,IAAI;MAAEC;IAAgB,CAAC,GAAAP,KAAA;IAC1F,IAAIQ,MAAM,GAAG3B,SAAS,CAACuB,MAAM,EAAEF,UAAU,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC;IACtD;AACR;AACA;IACQ,IAAIK,eAAe,EAAE;MACjB,IAAIJ,aAAa,EACbA,aAAa,GAAGI,eAAe,CAACJ,aAAa,CAAC;MAClD,IAAIC,MAAM,EACNA,MAAM,GAAGG,eAAe,CAACH,MAAM,CAAC;MACpC,IAAII,MAAM,EACNA,MAAM,GAAGD,eAAe,CAACC,MAAM,CAAC;IACxC;IACA,IAAIP,SAAS,EAAE;MACXnB,uBAAuB,CAAC,IAAI,EAAEsB,MAAM,EAAEI,MAAM,CAAC;MAC7C,MAAMC,MAAM,GAAG1B,eAAe,CAAC,IAAI,EAAEqB,MAAM,EAAEI,MAAM,EAAEL,aAAa,CAAC;MACnEA,aAAa,GAAGM,MAAM,CAACN,aAAa;MACpCC,MAAM,GAAGK,MAAM,CAACL,MAAM;IAC1B;IACA,OAAAM,aAAA;MACIR,UAAU;MACVC;IAAa,GACVC,MAAM;EAEjB;AACJ;AAEA,SAASnB,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}